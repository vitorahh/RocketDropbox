{"ast":null,"code":"/**\r\n * Module dependencies.\r\n */\nvar Transport = require('../transport');\n\nvar parser = require('engine.io-parser');\n\nvar parseqs = require('parseqs');\n\nvar inherit = require('component-inherit');\n\nvar yeast = require('yeast');\n\nvar debug = require('debug')('engine.io-client:websocket');\n\nvar BrowserWebSocket, NodeWebSocket;\n\nif (typeof WebSocket !== 'undefined') {\n  BrowserWebSocket = WebSocket;\n} else if (typeof self !== 'undefined') {\n  BrowserWebSocket = self.WebSocket || self.MozWebSocket;\n}\n\nif (typeof window === 'undefined') {\n  try {\n    NodeWebSocket = require('ws');\n  } catch (e) {}\n}\n/**\r\n * Get either the `WebSocket` or `MozWebSocket` globals\r\n * in the browser or try to resolve WebSocket-compatible\r\n * interface exposed by `ws` for Node-like environment.\r\n */\n\n\nvar WebSocketImpl = BrowserWebSocket || NodeWebSocket;\n/**\r\n * Module exports.\r\n */\n\nmodule.exports = WS;\n/**\r\n * WebSocket transport constructor.\r\n *\r\n * @api {Object} connection options\r\n * @api public\r\n */\n\nfunction WS(opts) {\n  var forceBase64 = opts && opts.forceBase64;\n\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n  this.protocols = opts.protocols;\n\n  if (!this.usingBrowserWebSocket) {\n    WebSocketImpl = NodeWebSocket;\n  }\n\n  Transport.call(this, opts);\n}\n/**\r\n * Inherits from Transport.\r\n */\n\n\ninherit(WS, Transport);\n/**\r\n * Transport name.\r\n *\r\n * @api public\r\n */\n\nWS.prototype.name = 'websocket';\n/*\r\n * WebSockets support binary\r\n */\n\nWS.prototype.supportsBinary = true;\n/**\r\n * Opens socket.\r\n *\r\n * @api private\r\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var uri = this.uri();\n  var protocols = this.protocols;\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  }; // SSL options for Node.js client\n\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n\n  if (this.localAddress) {\n    opts.localAddress = this.localAddress;\n  }\n\n  try {\n    this.ws = this.usingBrowserWebSocket && !this.isReactNative ? protocols ? new WebSocketImpl(uri, protocols) : new WebSocketImpl(uri) : new WebSocketImpl(uri, protocols, opts);\n  } catch (err) {\n    return this.emit('error', err);\n  }\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'nodebuffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n/**\r\n * Adds event listeners to the socket\r\n *\r\n * @api private\r\n */\n\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n/**\r\n * Writes data to socket.\r\n *\r\n * @param {Array} array of packets.\r\n * @api private\r\n */\n\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false; // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n\n  var total = packets.length;\n\n  for (var i = 0, l = total; i < l; i++) {\n    (function (packet) {\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\n        if (!self.usingBrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;\n\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        } // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n\n\n        try {\n          if (self.usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done() {\n    self.emit('flush'); // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n\n    setTimeout(function () {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n/**\r\n * Called upon close\r\n *\r\n * @api private\r\n */\n\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n/**\r\n * Closes socket.\r\n *\r\n * @api private\r\n */\n\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n/**\r\n * Generates uri for connection.\r\n *\r\n * @api private\r\n */\n\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = ''; // avoid port if default for schema\n\n  if (this.port && ('wss' === schema && Number(this.port) !== 443 || 'ws' === schema && Number(this.port) !== 80)) {\n    port = ':' + this.port;\n  } // append timestamp to URI\n\n\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  } // communicate binary support capabilities\n\n\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query); // prepend ? to query\n\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n/**\r\n * Feature detection for WebSocket.\r\n *\r\n * @return {Boolean} whether this transport is available.\r\n * @api public\r\n */\n\n\nWS.prototype.check = function () {\n  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);\n};","map":{"version":3,"sources":["C:/Users/Dominic/Documents/RocketDropbox/node_modules/engine.io-client/lib/transports/websocket.js"],"names":["Transport","require","parser","parseqs","inherit","yeast","debug","BrowserWebSocket","NodeWebSocket","WebSocket","self","MozWebSocket","window","e","WebSocketImpl","module","exports","WS","opts","forceBase64","supportsBinary","perMessageDeflate","usingBrowserWebSocket","forceNode","protocols","call","prototype","name","doOpen","check","uri","agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","extraHeaders","headers","localAddress","ws","isReactNative","err","emit","binaryType","undefined","supports","binary","addEventListeners","onopen","onOpen","onclose","onClose","onmessage","ev","onData","data","onerror","onError","write","packets","writable","total","length","i","l","packet","encodePacket","options","compress","len","Buffer","byteLength","threshold","send","done","setTimeout","doClose","close","query","schema","secure","port","Number","timestampRequests","timestampParam","b64","encode","ipv6","hostname","indexOf","path"],"mappings":"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","sourcesContent":["/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Transport = require('../transport');\r\nvar parser = require('engine.io-parser');\r\nvar parseqs = require('parseqs');\r\nvar inherit = require('component-inherit');\r\nvar yeast = require('yeast');\r\nvar debug = require('debug')('engine.io-client:websocket');\r\n\r\nvar BrowserWebSocket, NodeWebSocket;\r\n\r\nif (typeof WebSocket !== 'undefined') {\r\n  BrowserWebSocket = WebSocket;\r\n} else if (typeof self !== 'undefined') {\r\n  BrowserWebSocket = self.WebSocket || self.MozWebSocket;\r\n}\r\n\r\nif (typeof window === 'undefined') {\r\n  try {\r\n    NodeWebSocket = require('ws');\r\n  } catch (e) { }\r\n}\r\n\r\n/**\r\n * Get either the `WebSocket` or `MozWebSocket` globals\r\n * in the browser or try to resolve WebSocket-compatible\r\n * interface exposed by `ws` for Node-like environment.\r\n */\r\n\r\nvar WebSocketImpl = BrowserWebSocket || NodeWebSocket;\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = WS;\r\n\r\n/**\r\n * WebSocket transport constructor.\r\n *\r\n * @api {Object} connection options\r\n * @api public\r\n */\r\n\r\nfunction WS (opts) {\r\n  var forceBase64 = (opts && opts.forceBase64);\r\n  if (forceBase64) {\r\n    this.supportsBinary = false;\r\n  }\r\n  this.perMessageDeflate = opts.perMessageDeflate;\r\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\r\n  this.protocols = opts.protocols;\r\n  if (!this.usingBrowserWebSocket) {\r\n    WebSocketImpl = NodeWebSocket;\r\n  }\r\n  Transport.call(this, opts);\r\n}\r\n\r\n/**\r\n * Inherits from Transport.\r\n */\r\n\r\ninherit(WS, Transport);\r\n\r\n/**\r\n * Transport name.\r\n *\r\n * @api public\r\n */\r\n\r\nWS.prototype.name = 'websocket';\r\n\r\n/*\r\n * WebSockets support binary\r\n */\r\n\r\nWS.prototype.supportsBinary = true;\r\n\r\n/**\r\n * Opens socket.\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.doOpen = function () {\r\n  if (!this.check()) {\r\n    // let probe timeout\r\n    return;\r\n  }\r\n\r\n  var uri = this.uri();\r\n  var protocols = this.protocols;\r\n  var opts = {\r\n    agent: this.agent,\r\n    perMessageDeflate: this.perMessageDeflate\r\n  };\r\n\r\n  // SSL options for Node.js client\r\n  opts.pfx = this.pfx;\r\n  opts.key = this.key;\r\n  opts.passphrase = this.passphrase;\r\n  opts.cert = this.cert;\r\n  opts.ca = this.ca;\r\n  opts.ciphers = this.ciphers;\r\n  opts.rejectUnauthorized = this.rejectUnauthorized;\r\n  if (this.extraHeaders) {\r\n    opts.headers = this.extraHeaders;\r\n  }\r\n  if (this.localAddress) {\r\n    opts.localAddress = this.localAddress;\r\n  }\r\n\r\n  try {\r\n    this.ws =\r\n      this.usingBrowserWebSocket && !this.isReactNative\r\n        ? protocols\r\n          ? new WebSocketImpl(uri, protocols)\r\n          : new WebSocketImpl(uri)\r\n        : new WebSocketImpl(uri, protocols, opts);\r\n  } catch (err) {\r\n    return this.emit('error', err);\r\n  }\r\n\r\n  if (this.ws.binaryType === undefined) {\r\n    this.supportsBinary = false;\r\n  }\r\n\r\n  if (this.ws.supports && this.ws.supports.binary) {\r\n    this.supportsBinary = true;\r\n    this.ws.binaryType = 'nodebuffer';\r\n  } else {\r\n    this.ws.binaryType = 'arraybuffer';\r\n  }\r\n\r\n  this.addEventListeners();\r\n};\r\n\r\n/**\r\n * Adds event listeners to the socket\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.addEventListeners = function () {\r\n  var self = this;\r\n\r\n  this.ws.onopen = function () {\r\n    self.onOpen();\r\n  };\r\n  this.ws.onclose = function () {\r\n    self.onClose();\r\n  };\r\n  this.ws.onmessage = function (ev) {\r\n    self.onData(ev.data);\r\n  };\r\n  this.ws.onerror = function (e) {\r\n    self.onError('websocket error', e);\r\n  };\r\n};\r\n\r\n/**\r\n * Writes data to socket.\r\n *\r\n * @param {Array} array of packets.\r\n * @api private\r\n */\r\n\r\nWS.prototype.write = function (packets) {\r\n  var self = this;\r\n  this.writable = false;\r\n\r\n  // encodePacket efficient as it uses WS framing\r\n  // no need for encodePayload\r\n  var total = packets.length;\r\n  for (var i = 0, l = total; i < l; i++) {\r\n    (function (packet) {\r\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\r\n        if (!self.usingBrowserWebSocket) {\r\n          // always create a new object (GH-437)\r\n          var opts = {};\r\n          if (packet.options) {\r\n            opts.compress = packet.options.compress;\r\n          }\r\n\r\n          if (self.perMessageDeflate) {\r\n            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;\r\n            if (len < self.perMessageDeflate.threshold) {\r\n              opts.compress = false;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Sometimes the websocket has already been closed but the browser didn't\r\n        // have a chance of informing us about it yet, in that case send will\r\n        // throw an error\r\n        try {\r\n          if (self.usingBrowserWebSocket) {\r\n            // TypeError is thrown when passing the second argument on Safari\r\n            self.ws.send(data);\r\n          } else {\r\n            self.ws.send(data, opts);\r\n          }\r\n        } catch (e) {\r\n          debug('websocket closed before onclose event');\r\n        }\r\n\r\n        --total || done();\r\n      });\r\n    })(packets[i]);\r\n  }\r\n\r\n  function done () {\r\n    self.emit('flush');\r\n\r\n    // fake drain\r\n    // defer to next tick to allow Socket to clear writeBuffer\r\n    setTimeout(function () {\r\n      self.writable = true;\r\n      self.emit('drain');\r\n    }, 0);\r\n  }\r\n};\r\n\r\n/**\r\n * Called upon close\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.onClose = function () {\r\n  Transport.prototype.onClose.call(this);\r\n};\r\n\r\n/**\r\n * Closes socket.\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.doClose = function () {\r\n  if (typeof this.ws !== 'undefined') {\r\n    this.ws.close();\r\n  }\r\n};\r\n\r\n/**\r\n * Generates uri for connection.\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.uri = function () {\r\n  var query = this.query || {};\r\n  var schema = this.secure ? 'wss' : 'ws';\r\n  var port = '';\r\n\r\n  // avoid port if default for schema\r\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\r\n    ('ws' === schema && Number(this.port) !== 80))) {\r\n    port = ':' + this.port;\r\n  }\r\n\r\n  // append timestamp to URI\r\n  if (this.timestampRequests) {\r\n    query[this.timestampParam] = yeast();\r\n  }\r\n\r\n  // communicate binary support capabilities\r\n  if (!this.supportsBinary) {\r\n    query.b64 = 1;\r\n  }\r\n\r\n  query = parseqs.encode(query);\r\n\r\n  // prepend ? to query\r\n  if (query.length) {\r\n    query = '?' + query;\r\n  }\r\n\r\n  var ipv6 = this.hostname.indexOf(':') !== -1;\r\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\r\n};\r\n\r\n/**\r\n * Feature detection for WebSocket.\r\n *\r\n * @return {Boolean} whether this transport is available.\r\n * @api public\r\n */\r\n\r\nWS.prototype.check = function () {\r\n  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}